<!DOCTYPE HTML>
<html>
	<head>
		<title>Dan Docs</title>
		<meta charset="utf-8" />

		<style type="text/css">

			body
			{
				font-family: "times new roman", serif, verdana;
				margin: 0px;
				background-color: #FFFFFF;
				padding: 8px;
			}

			li
			{
				margin-top: 10px;
			}

			code
			{
				white-space: pre;
			}

			.gray_title
			{
				width: 100%;
				background-color: #C0C0C0;
				margin-bottom: 15px;
				font-size: 24px;
			}

			.list_head
			{
				margin-bottom: 0px;
			}

			.list_item
			{
				margin-top: 0px;
				margin-bottom: 0px;
			}

			.list_tab
			{
				margin-top: 0px;
				margin-bottom: 0px;
				width: 100%;
			}

			.x
			{
				margin-top: 0px;
				margin-bottom: 0px;
				float: left;
				width: 30%;
			}

			.y
			{
				margin-top: 0px;
				margin-bottom: 0px;
				float: left;
			}

		</style>
	</head>

	<p class="gray_title">Dan Docs</p>

	<p class="list_head"><strong>Overview</strong></p>
	<p class="list_item"><a href="#about">About Dan Docs</a></p>

	<p class="list_head"><strong>Barcode Boy</strong></p>
	<p class="list_item"><a href="#bcb_gen">General Hardware Information</a></p>
	<p class="list_item"><a href="#bcb_gam">Compatible Games</a></p>
	<p class="list_item"><a href="#bcb_com">Barcode Boy to DMG Communication</a></p>
	<p class="list_item"><a href="#bcb_bar">Barcode Format</a></p>
	<p class="list_item"><a href="#bcb_rip">Card Dumping + Emulation</a></p>
	<p class="list_item"><a href="#bcb_err">Barcode Errors</a></p>

	<p class="list_head"><strong>Barcode Taisen Bardigun Scanner</strong></p>
	<p class="list_item"><a href="#btb_gen">General Hardware Information</a></p>
	<p class="list_item"><a href="#btb_com">Card Reader to GBC Communication</a></p>
	<p class="list_item"><a href="#btb_bar">Barcode Format</a></p>
	<p class="list_item"><a href="#btb_rip">Card Dumping</a></p>

	<p class="list_head"><strong>DMG-07 4-Player Adapter</strong></p>
	<p class="list_item"><a href="#dmg07_gen">General Hardware Information</a></p>
	<p class="list_item"><a href="#dmg07_gam">Compatible Games</a></p>
	<p class="list_item"><a href="#dmg07_pro">Link Cable Protocol</a></p>
	<p class="list_item"><a href="#dmg07_pin">Ping Phase</a></p>
	<p class="list_item"><a href="#dmg07_tra">Transmission Phase</a></p>
	<p class="list_item"><a href="#dmg07_res">Restarting Ping Phase</a></p>

	<p class="list_head"><strong>Zok Zok Heroes Full Changer</strong></p>
	<p class="list_item"><a href="#zzh_gen">General Hardware Information</a></p>
	<p class="list_item"><a href="#zzh_opr">Operation</a></p>
	<p class="list_item"><a href="#zzh_com">IR Communication</a></p>
	<p class="list_item"><a href="#zzh_cap">Capturing IR Data</a></p>
	<p class="list_item"><a href="#zzh_emu">Emulation</a></p>
	
	<p class="list_head"><strong>GBA Screen Stretch</strong></p>
	<p class="list_item"><a href="#gss_gen">General Information</a></p>

	<p class="list_head"><strong>GBC Infrared Communication</strong></p>
	<p class="list_item"><a href="#ir_gen">General Hardware Information</a></p>
	<p class="list_item"><a href="#ir_gam">Compatible Games</a></p>
	<p class="list_item"><a href="#ir_typ">Communication Types</a></p>
	<p class="list_item"><a href="#ir_pro">Communication Protocol</a></p>
	<p class="list_item"><a href="#ir_reg">RP Register</a></p>
	<p class="list_item"><a href="#ir_fad">Signal Fade</a></p>
	<p class="list_item"><a href="#ir_obs">Obscure Behavior</a></p>
	<p class="list_item"><a href="#ir_pp2">Pokemon Pikachu 2</a></p>
	<p class="list_item"><a href="#ir_sak">Pocket Sakura</a></p>

	<p class="list_head"><strong>Gyogun Tanchiki: Pocket Sonar</strong></p>
	<p class="list_item"><a href="#ps_gen">General Hardware Information</a></p>
	<p class="list_item"><a href="#ps_mbc">MBC1S</a></p>
	<p class="list_item"><a href="#ps_fmt">Sonar Format</a></p>
	<p class="list_item"><a href="#ps_fsh">Fish Finder</a></p>
	<p class="list_item"><a href="#ps_gbi">Game Boy Incompatibilities</a></p>
	<p class="list_item"><a href="#ps_rsc">Further Research</a></p>

	<a name="about"></a>
	<p class="gray_title">About Dan Docs</p>

	<p>For the longest time, a technical document called Pan Docs formed the basis of nearly all known documentation about the Nintendo Game Boy. To this day, Pan Docs (or an updated version such as the GBDev wiki) continues to be the go-to source of general Game Boy information. However, while Pan Docs covers the basics well enough, it does not touch upon more obscure Game Boy hardware. Dan Docs, on the other hand, aims to fill this gap. Dan Docs is basically everything else you wanted to know about the Game Boy, but no one dared to ask.</p>

	<p>All of the data here comes from my research for the GBE+ project. Much of this information is copied+pasted from the text files I&#39;ve made over the years. For ease of use and access, however, it&#39;s been converted to a single HTML document. As more items are reverse-engineered and studied, they will be added to Dan Docs as well as GBE+.</p>

	<!-- Barcode Boy -->

	<a name="bcb_gen"></a>
	<p class="gray_title">[Barcode Boy] : General Hardware Information</p>

	<p>Appearing around 1992, the Barcode Boy is the earliest form of card-scanning on Nintendo&#39;s Game Boy line of handhelds, predating both the e-Reader and the Bardigun Taisen Reader by a number of years. Only a limited set of games made by Namcot were compatible with (or rather absolutely required) the Barcode Boy. All of the games and the Barcode Boy itself were only released in Japan.</p>

	<ul>
		<li class="list_item">Barcode Boy is a rather bulky add-on that snaps on top of the original DMG (the gray &#34;brick&#34;)</li>
		<li class="list_item">Barcode Boy requires 2 AA batteries (with a DMG-01, that brings the total to 6 AA necessary to play any Barcode Boy game)</li>
		<li class="list_item">Barcode Boy WILL NOT WORK WITH OTHER GAME BOYS! For whatever reason using the Universal Link Cable (MGB-010) will not work.</li>
		<li class="list_item">Barcode Boy games are always labeled with a &#34;B.B.&#34; logo with a little card.</li>
		<li class="list_item">Includes a very, very short Link Cable</li>
		<li class="list_item">Unlike the Barcode Taisen Bardigun reader, the Barcode Boy has no button. It is always &#34;ON&#34; when switched on, thus draining batteries even while not scanning</li>
	</ul>

	<a name="bcb_gam"></a>
	<p class="gray_title">[Barcode Boy] : Compatible Games</p>

	<p>Only 5 Barcode Boy games are known to exist:</p>

	<ul>
		<li class="list_item">Battle Space</li>
		<li class="list_item">Monster Maker Barcode Saga</li>
		<li class="list_item">Kattobi Road</li>
		<li class="list_item">Family Jockey 2</li>
		<li class="list_item">Famista 3</li>
	</ul>

	<p>Barcode Boy titles come in two types: those that absolutely require the Barcode Boy for any gameplay at all (専用カートリッジ) and those that merely support the Barcode Boy as an accessory for additional content (対応カートリッジ). These games are differentiated with red and blue &#34;B.B.&#34; logos respectively. Only Battle Space and Monster Maker: Barcode Saga fall into the first group.</p>

	<a name="bcb_com"></a>
	<p class="gray_title">[Barcode Boy] : Barcode Boy to DMG Communication</p>

	<p>Each game will first try to detect if the Barcode Boy is plugged in and turned on. The Game Boy will send the bytes [0x10, 0x07, 0x10, 0x07] as part of a handshake. A properly functioning Barcode Boy will return the bytes [0xFF, 0xFF, 0x10, 0x07]. Barcode Boy games will still successfully detect the Barcode Boy scanner even if the first two bytes in the reply to the handshake aren&#39;t 0xFF, probably to simplify the game code. As a result, the first two bytes of the handshake are useless and ignored, but the last two bytes *MUST* be [0x10, 0x07]. If the Barcode Boy is plugged in but not turned on, it responds with 0x00 for the entire handshake, and the game produces an error message.</p>

	<p>After detection passes, the Game Boy will sit and wait for a response. The Game Boy, unlike how it works with other SIO devices, takes on a passive role with the Barcode Boy by switching to an external clock. The Game Boy actually requires the Barcode Boy to take the initiative when scanning. Therefore, it is assumed that the Barcode Boy uses an internal clock and drives serial communications while scanning a barcode.</p>

	<p>Nitty-gritty bits:</p>
	
	<ol>
		<li>The game logic pings the Barcode Boy with [0x10, 0x07, 0x10, 0x07]. The Barcode Boy is expected to reply; the first two bytes are not important (real hardware returns 0xFF), but the second two bytes must be [0x10, 0x07].</li>
		<li>Afterwards, the Game Boy waits for input using an external clock. What follows are two strings of numbers representing the barcode data. The &#34;numbers&#34; are represented as ASCII instead of hex.</li>
		<li>Both strings are 13-digits long and are the EAN-13 number corresponding to the barcode.</li>
		<li>Before sending each string, the Barcode Boy sends a 0x02 byte.</li>
		<li>After sending each string, the Barcode Boy sends a 0x03 byte.</li>
		<li>Altogether, the Barcode Boy transmits 30 bytes to the Game Boy.</li>
	</ol>

	<p>Overall known communication protocol:</p>

	<ul>
		<li>Handshake -&gt; Send [0x10, 0x07, 0x10, 0x07] : Receive [0xFF, 0xFF, 0x10, 0x07]</li>
		<li>Start Barcode Data Transmission -&gt; [0x02]</li>
		<li>Stop Barcode Data Transmission -&gt; [0x03]</li>
	</ul>

	<p>Standard communication flow:</p>

<code>[DMG]			[BCB]
Handshake	---&gt;
		&lt;---	Handshake

		&lt;---	0x2
		&lt;---	EAN-13
		&lt;---	0x3

		&lt;---	0x2
		&lt;---	EAN-13
		&lt;---	0x3</code>

	<p>Since the Barcode Boy acts as master (after the handshake at least), the Game Boy never initiates a transfer during barcode transmission. When sending barcode data, the Barcode Boy doesn&#39;t seem to care what value the Game Boy writes to SB, although no Barcode Boy games write to SB at that time anyway. Ultimately unknown if the Barcode Boy accepts input beyond the handshake, but no evidence has been observed to suggest otherwise.</p>

	<p>Once the Barcode Boy sends the handshake [0x10, 0x07] back to the Game Boy, the scanner returns 0xFF anytime the Game Boy tries to send additional data while the handheld is still on its own internal clock. After the Barcode Boy finishes sending back the barcode data to the Game Boy, it requires the handshake again. It appears the handshake can fail for unknown reasons (probably related to the hardware). For example, the Barcode Boy at times may send back [0x90, 0x07], which seems to indicate an error of some sort.</p>

	<a name="bcb_bar"></a>
	<p class="gray_title">[Barcode Boy] : Barcode Format</p>

	<p>The two strings are the actual barcode data in numerical form. The barcode format itself is EAN-13, and a few games use JAN-13 specifically. Older JAN-13 barcodes start off with the flag code 49. Interestingly enough, the newer JAN-13 flag code is 45 and was introduced in 1992, the same year the Barcode Boy was released. Probably due to timing or convenience, the JAN-13 barcodes on the cards stuck to the older flag code. Some Barcode Boy barcodes are technically &#34;coupons&#47;vouchers&#34; types, as they use the flag code 99 instead of 45 or 49. Family Jockey 2 and Famista 3 don&#39;t use JAN-13 specifically; instead they use random EAN-13 barcodes with varying flag codes.</p>

	<p>Using scans of the barcode @ 600 DPI, the smallest bar width is approximately 7 pixels (give or take). With that information, it&#39;s possible to recreate the EAN-13 number with a sufficient image and barcode scanning software. It should be noted that the Barcode Boy appears to do away with the center guard, however, it maintains left and right guards.</p>

	<a name="bcb_rip"></a>
	<p class="gray_title">[Barcode Boy] : Card Dumping + Emulation</p>

	<p>Amazingly simple in comparison to something like Barcode Taisen Bardigun, chiefly because such a small amount of bytes need to be sent to the Game Boy. Basically, all you need to do is convert the barcode to EAN-13. Anything capable of reading standard barcodes found on most products should be sufficient to grab the numerical form of each card.</p>

	<p>As far as emulation goes, simply convert the EAN-13 ASCII string to hex and transmit it accordingly.</p>

	<a name="bcb_err"></a>
	<p class="gray_title">[Barcode Boy] : Barcode Errors</p>

	<p>Interestingly enough, a vast majority of the barcodes for Family Jockey 2 are completely incorrect. Only 3 out of the 8 barcodes actually generate horses with the stats listed on the cards. Barcodes A1, B1, and A4 work fine; the rest give stats that do not match up with the card&#39;s. Some, such as A2, even generate horses that are totally unfit for competition (A2 produces stats with 2s and 0s, and the max is supposed to be 9 in each category). It&#39;s not clear if this was a programming glitch or a mistake Namcot made when printing the cards, or some combination of the two. All other Barcode Boy games came packaged with cards that have no issues whatsoever.</p>


	<!-- Barcode Taisen Bardigun -->

	<a name="btb_gen"></a>
	<p class="gray_title">[Barcode Taisen Bardigun] : General Hardware Information</p>

	<p>Barcode Taisen Bardigun is a Japanese Game Boy game released December 11, 1998, made by TAM. It doesn&#39;t seem like a very interesting or noteworthy game in and of itself (yet another monster breeding&#47;raising&#47;fighting&#47;collecting game). However, this game featured exclusive hardware, a card reader that scanned various barcodes</p>

	<ul>
		<li class="list_item">Barcode Taisen Bardigun (DMG-ABEJ-JPN)</li>
		<li class="list_item">MBC3 + RTC + Battery Saves (Same as Pokemon Gold and Silver)</li>
		<li class="list_item">Compatible with DMG, SGB, and GBC systems</li>
		<li class="list_item">Japanese-text only (hiragana&#47;katakana only, a bit of a blessing given 8x8 fonts are not the best for kanji)</li>
		<li class="list_item">Supports Link Cable for multiplayer</li>
		<li class="list_item">Comes with 1 card-reader powered by 3 AAA batteries</li>
		<li class="list_item">Comes with 5 cards bundled (only 3 have barcodes, the other 2 are just collectables?)</li>
		<li class="list_item">Reader connects to DMG/GBC serial port for communication</li>
	</ul>

	<a name="btb_com"></a>
	<p class="gray_title">[Barcode Taisen Bardigun] : Card Reader to GBC Communication</p>

	<p>Game Boy will initialize a transfer with an internal clock; much like every other Serial I/O device (GB Printer, GB Mobile Adapter), Game Boy sends initial data, then the reader responds. Transfer rate is 1KB&#47;s, the slowest speed, so there is no difference between DMG and GBC transfers. To begin, the Game Boy constantly sends 0xFF to the reader. The game logic times out after a few seconds if no proper response is established.</p>

	<p>To scan a card, hold it face down (barcode facing the ground and towards the reader), press the reader&#39;s button, and swipe. The scanner only seems to activate once the button is pushed (otherwise it&#39;d waste battery if it were constantly on, or constantly on and trying to receieve commands from the Game Boy). Without pressing the button, the game logic times out the scanning process after a few seconds (about 9 seconds). If an error is detected during the scan process, the reader seems to acknowledge this pretty quickly.</p>

	<p>Nitty-gritty bits</p>

	<ol>
		<li>When connected, the reader responds with 0x00 until it is prepared to send the barcode data.</li>

		<li>Afterwards, it begins processing barcode data. Data is represented serially. A bit reading &#34;1&#34; indicates that the card reader is detecting whitespace. A bit reading &#34;0&#34; indicates the card reader is detecting a black segment (black bar).</li>

		<li>The barcode sequence itself is nothing more than a continuous stream of zeroes and ones. That is to say, groups of ones and zeroes are always packed together, but the length of each group determines the length of any given bar.</li>

		<li>There doesn&#39;t appear to be a fixed number of bytes that the Game Boy seems to expect when scanning. Different scans seem to produce different amounts of data transferred to the Game Boy. This could be due to numerous reasons in the hardware (swipe speed, how clean the scanner is, some other variance within the scanner&#39;s light sensitivity). Overall, however, the most important thing seems to be the length and sequence of the bars encoded as groups of ones and zeroes.</li>

		<li>The Game Boy doesn&#39;t ever seem to send any interesting data, just 0xFF. No commands are sent. The Game Boy simply sends a byte and expects a result to come from the reader; the results are what matter and are interpreted later on.</li>

	</ol>

	<a name="btb_bar"></a>
	<p class="gray_title">[Barcode Taisen Bardigun] : Barcode Format</p>

	<p>Because the incoming barcode data is not consistent byte-for-byte, the patterns are what matters most. To illustrate this idea, below are two sets of data extracted after scanning a card (using a hacked version of Barcode Taisen Bardigun and saving all SIO communications to Cart RAM).</p>

<code>SET_1		SET_2
00 00		00 03		
7F FE		FF F8
00 01		00 03
FF FF 		FF FF
FF FF		FF FF
FF C0		FF E0
00 3F		00 0F
FF 00		FF 80
00 00		00 00
07 FF		00 FF
00 00		FC 00
FF FF		03 FF
FF C0		FF FF
00 00		C0 00</code>

<p>Each set is actually a bitstream of 0s and 1s like so:</p>

<code>Set 1 [16:0] [14:1] [15:0] [43:1] ...
Set 2 [14:0] [15:1] [14:0] [45:1] ...</code>

	<p>The patterns in the sets are roughly the same. They switch between 0s, 1s, and 0s (black, white, black) fairly quickly followed by a long segment of 1s (white) which is roughly the general pattern seen at the beginning&#47;ends of the barcodes. Based on this information, the thinest bars are about 0.0133 inches (8 pixels when scanning at 600dpi). Some further calculations based on this information:</p>

<code>Bar Width (in pixels @ 600dpi) -&gt; Estimated bit-count sent to Game Boy

8	-&gt;	~14-16
16	-&gt;	~27-29
24	-&gt;	~43-45</code>

	<p>Every 8 pixels should be approximately 15 bits worth of data sent to the Game Boy, so:</p>

	<code>Number of Pixels @ 600dpi * 1.875 = Approximate bit count</code>

	<a name="btb_rip"></a>
	<p class="gray_title">[Barcode Taisen Bardigun] : Card Dumping</p>

	<p>With the above guideline, it is possible to dump the cards by scanning them, then creating a binary file containing barcodes as alternating bitstreams of 0s and 1s. With this method, no homebrew techniques are needed, and only an image file is necessary to actually preserve the card.</p>

	<p>The second method involves using a hacked version of the Barcode Taisen Bardigun ROM on a flashcart to save incoming Serial I&#47;O data as a card is scanned. The binary can be pulled from a save file. Both binary files could be used an input to feed back to an emulator.</p>

	<!-- DMG-07 -->

	<a name="dmg07_gen"></a>
	<p class="gray_title">[DMG-07] : General Hardware Information</p>

	<p>The DMG-07 is an accessory that allows 4 Game Boys to connect for multiplayer. In the West, it first appeared with the game F-1 Race as bundle in 1990. Only a few other games took advantage of the DMG-07 (namely Wave Race and Faceball 2000, Yoshi&#39;s Cookie) and it did not see widespread support at all.</p>

	<ul>
		<li class="list_item">DMG-07 is a gray &#34;hub&#34; with 3 input ports for Gen 1 Link Cables.</li>
		<li class="list_item">DMG-07 is largely designed for Gen 1 Link Cables and DMG models. MGB-010s allow any Game Boy (up to the Micro) to connect as Players 2-4.</li>
		<li class="list_item">Player 1 comes with a built-in cable (Gen 1). All other players need extra cables.</li>
		<li class="list_item">Player 1 needs to be a DMG model unless an MGB-004 adapter is used.</li>
		<li class="list_item">DMG-07 uses a Motorola 402038 for multiplexing stuff.</li>
	</ul>

	<a name="dmg07_gam"></a>
	<p class="gray_title">[DMG-07] : Compatible Games</p>

	<ul>
		<li class="list_item">Chachamaru Panix</li>
		<li class="list_item">Downtown Nekketsu Koushinkyoku: Dokodemo Daiundoukai</li>
		<li class="list_item">Faceball 2000</li>
		<li class="list_item">F1 Race</li>
		<li class="list_item">F1 Pole Position</li>
		<li class="list_item">Nekketsu Koukou Dodge Ball-Bu</li>
		<li class="list_item">Super R.C. Pro-Am</li>
		<li class="list_item">Top Rank Tennis</li>
		<li class="list_item">Trax</li>
		<li class="list_item">Trump Boy II</li>
		<li class="list_item">Uno: Small World 2</li>
		<li class="list_item">Wave Race</li>
		<li class="list_item">Yoshi&#39;s Cookie</li>
	</ul>

	<a name="dmg07_pro"></a>
	<p class="gray_title">[DMG-07] : Link Cable Protocol</p>

	<p>The DMG-07 protocol can be divided into 2 sections, the &#34;ping&#34; phase, and the &#34;transmission&#34; phase. The initial ping phase involves sending packets back and forth between connected Game Boys probing for their current connection status. Afterwards, the DMG-07 enters into transmission mode where the Game Boys exchange data across the network.</p>

	<p>A very important thing to note is that all Game Boys transfer data across the DMG-07 via an external clock source. Apparently, the clock source is provided by the DMG-07 itself. Trying to send data via an internal clock results in garbage data.</p>

	<a name="dmg07_pin"></a>
	<p class="gray_title">[DMG-07] : Ping Phase</p>

	<p>When a &#34;master&#34; Game Boy (Player 1) is first connected to the DMG-07, setting Bit 7 of 0xFF02 to 1 and setting Bit 0 of 0xFF02 to 0 causes the accessory to send out "ping" packets periodically. All connected Game Boys will receive 4 bytes as part of the ping packet, at a rate of about 2048 bits-per-second, or about 256 bytes-per-second. Essentially, the ping seems to run 1&#47;4 as fast as the clock used for normal serial transfers on the DMG (1KB&#47;s). The ping data looks like this:</p>

	<code>0xFE		ID Byte
0x??		STAT1
0x??		STAT2
0x??		STAT3</code>

	<p>3 &#34;STAT&#34; bytes are sent indicating the current connection status of the other Game Boys. Each byte is usually the same, however, sometimes the status can change mid-way through a ping, typically on STAT2 or STAT3. Each STAT byte looks like such:</p>

	<code>Bit 0-2: 	Player ID
Bit 4:		Player 1 Connected
Bit 5:		Player 2 Connected
Bit 6:		Player 3 Connected
Bit 7:		Player 4 Connected</code>

	<p>The Player ID is simply a value of 1-4. Its value is determined by whichever port a Game Boy is connected to. As more Game Boys connect, the upper bits of the STAT bytes are turned on.</p>

	<p>When talking about Game Boys and the &#34;connection&#34;, this refers to a Game Boy properly responding to STAT1 and STAT2 bytes when receiving a ping packet from the DMG-07. In this way, the Game Boy broadcasts across the Link Cable network that it is an active participant in communications. It also acts as a sort of acknowledgement signal, where software can drop a Game Boy if the DMG-07 detects an improper response during a ping, or a Game Boy simply quits the network. The proper response is to send 0x88 *after* receiving the ID Byte and STAT1, in which case the upper-half of STAT1, STAT2, and STAT3 are updated to show that a Game Boy is &#34;connected&#34;. If for whatever reason, the acknowledgement codes are not sent, the above bits are unset.</p>

	<p>Some examples of ping packets are shown below:</p>

	<code>0xFE 0x01 0x01 0x01	-&gt;	Ping packet received by Player 1 with no other Game Boys connected
0xFE 0x11 0x11 0x11	-&gt;	Ping packet received by Player 1 when Player 1 has connected
0xFE 0x31 0x31 0x31	-&gt;	Ping packet received by Player 1 when Players 1 & 2 have connected
0xFE 0x71 0x71 0x71	-&gt;	Ping packet received by Player 1 when Players 1, 2, & 3 have connected
0xFE 0x62 0x62 0x62	-&gt;	Ping packet received by Player 2 when Players 2 & 3 are connected (but not Player 1)</code>

	<p>It&#39;s possible to have situations where some players are connected but others are not; the gaps don&#39;t matter. For example, Player 1 and Player 4 can be connected, while Player 2 and Player 3 can be disconnected (or non-existant, same thing); most games do not care so long as Player 1 is active, as that Game Boy acts as master and orchestrates the multiplayer session from a software point of view. Because of the way the DMG-07 hardcodes player IDs based on which port a Game Boy is physically connected to, in the above situation Player 4 wouldn&#39;t suddenly become Player 2 in a game like F-1 Race.</p>

	<p>During the ping phase, the master Game Boy is capable of setting up two parameters that will be used during the transmission phase. The clock rate for the transmission phase can be adjusted, as well as the packet size each Game Boy will use. The master Game Boy needs to respond with one byte for STAT2 and STAT3 respectively. The chart below illustrates how a master Game Boy should respond to all bytes in a ping packet:</p>

<code>----------------------------
DMG-07		Game Boy
----------------------------
0xFE	&lt;--&gt;	(ACK1) = 0x88
STAT1	&lt;--&gt;	(ACK2) = 0x88	
STAT2	&lt;--&gt;	(RATE) = Link Cable Speed 
STAT3	&lt;--&gt;	(SIZE) = Packet Size</code>

	<p>The new clock rate is only applied when entering the transmission phase; the ping phase runs at a constant 2048 bits-per-second. The formula for the new clock rate is as follows:</p>

<code>DMG-07 Bits-Per-Second --&gt; 4194304 &#47; ((6 * RATE) + 512)</code>

	<p>The lowest setting (RATE = 0) runs the DMG-07 at the normal speed DMGs usually transfer data (1KB&#47;s), while setting it to 0xFF runs its close to the slowest speed (2042 bits-per-second).</p>

	<p>SIZE sets the length of packets exchanged between all Game Boys. Nothing fancy, just the number of bytes in each packet. It probably shouldn&#39;t be set to zero.</p>

	<a name="dmg07_tra"></a>
	<p class="gray_title">[DMG-07] : Transmission Phase</p>

	<p>When the master Game Boy (Player 1) is ready, it should send 4 bytes (0xAA 0xAA 0xAA 0xAA). Some games only send 3 bytes however (0xAA 0xAA 0xAA and 0x00). This alerts the DMG-07 to start the transmission phase. The RATE and SIZE parameters are applied at this point. The protocol is simple: Each Game Boy sends a packet to the DMG-07 simultaneously, then the DMG-07 outputs each packet to all connected Game Boys. All data is buffered, so there is a 4 packet delay after each Game Boy submits their data (the delay is still 4 packets long even if some Game Boys are not connected). For example, say the packet size is 4 bytes; the flow of data would look like this when sending:</p>


<code>--------------------------------------------------------------------------------------------
P1 send		P2 send		P3 send		P4 send		Transfer count
--------------------------------------------------------------------------------------------
P1_byte_1	P2_byte_1	P3_byte_1	P4_byte_1	0
P1_byte_2	P2_byte_2	P3_byte_2	P4_byte_2	1
P1_byte_3	P2_byte_3	P3_byte_3	P4_byte_3	2
P1_byte_4	P2_byte_4	P3_byte_4	P4_byte_4	3

0		0		0		0		4 (Typically supposed to be zero, but DMG-07 ignores anything here)
0		0		0		0		5
0		0		0		0		6
0		0		0		0		7

0		0		0		0		8
0		0		0		0		9
0		0		0		0		10
0		0		0		0		11

0		0		0		0		12
0		0		0		0		13
0		0		0		0		14
0		0		0		0		15</code>

	<p>And when receiving, the flow of data would look like this:</p>

<code>--------------------------------------------------------------------------------------------
P1 recv		P2 recv		P3 recv		P4 recv		Transfer count
--------------------------------------------------------------------------------------------
P1_byte_1	P1_byte_1	P1_byte_1	P1_byte_1	16
P1_byte_2	P1_byte_2	P1_byte_2	P1_byte_2	17
P1_byte_3	P1_byte_3	P1_byte_3	P1_byte_3	18
P1_byte_4	P1_byte_4	P1_byte_4	P1_byte_4	19

P2_byte_1	P2_byte_1	P2_byte_1	P2_byte_1	20
P2_byte_2	P2_byte_2	P2_byte_2	P2_byte_2	21
P2_byte_3	P2_byte_3	P2_byte_3	P2_byte_3	22
P2_byte_4	P2_byte_4	P2_byte_4	P2_byte_4	23

P3_byte_1	P3_byte_1	P3_byte_1	P3_byte_1	24
P3_byte_2	P3_byte_2	P3_byte_2	P3_byte_2	25
P3_byte_3	P3_byte_3	P3_byte_3	P3_byte_3	26
P3_byte_4	P3_byte_4	P3_byte_4	P3_byte_4	27

P4_byte_1	P4_byte_1	P4_byte_1	P4_byte_1	28
P4_byte_2	P4_byte_2	P4_byte_2	P4_byte_2	29
P4_byte_3	P4_byte_3	P4_byte_3	P4_byte_3	30
P4_byte_4	P4_byte_4	P4_byte_4	P4_byte_4	31</code>

	<p>Again, due to buffering, data output to the DMG-07 is actually delayed by several transfers according to the size of the packets. All connected Game Boys should send their data into the buffer during the first few transfers. Here, the packet size is 4 bytes, so each Game Boy should submit their data during the first 4 transfers. The other 12 transfers don&#39;t care what the Game Boys send; it won&#39;t enter into the buffer. The next 16 transfers return the packets each Game Boy previously sent (if no Game Boy exists for player, that slot is filled with zeroes).</p>

	<p>With the buffering system, Game Boys would normally be reading data from previous packets during transfers 0-15, in addition to sending new packets. Likewise, during transfers 16-19 each Game Boy is sending new packets. In effect, while receiving old data, Game Boys are supposed to pump new data into the network.</p>

	<p>When the DMG-07 enters the transmission phase, the buffer is initially filled with garbage data that is based on output the master Game Boy had sent during the ping phase. At this time, it is recommended to ignore the earliest packets received, however, it is safe to start putting new, relevant data into the buffer.</p>

	<a name="dmg07_res"></a>
	<p class="gray_title">[DMG-07] : Restarting Ping Phase</p>

	<p>It&#39;s possible to restart the ping phase while operating in the transmission phase. To do so, the master Game Boy should send 4 or more bytes (0xFF 0xFF 0xFF 0xFF). Again, some games send less (0xFF 0xFF 0xFF and 0x00). It&#39;s possible only 1 or 2 0xFF bytes need to be sent, but this has not been extensively investigated yet. At any rate, the bytes alert the DMG-07 that the ping phase should begin again. Most games use this to end the multiplayer session and return to the title screen. For example, in F-1 Race, the game automatically jumps back to the title screen after all races have been completed, while Wave Race has a menu to continue playing or end the session. In either case, the games send 0xFF bytes and the DMG-07 sends ping packets after a brief delay. During this delay, the transmission protocol is still working as intended until the switch happens.</p>

	<!-- Zok Zok Heroes Full Changer -->

	<a name="zzh_gen"></a>
	<p class="gray_title">[Full Changer] : General Hardware Information</p>

	<p>Zok Zok Heroes was a GBC JRPG released on August 4, 2000, made by Media Factory when they still produced video games. It used a special accessory called the &#34;Full Changer&#34;, a device that looks like a toy, but acts as an IR transmitter. It sent signals to the GBC once players moved it through the air to &#34;draw&#34; certain patterns. Once the GBC gets the IR light pulses, it allows players to transform into different &#34;Bright Heroes&#34; to do battle against evil bad guys. It never sold outside of Japan. After a specific point early in the game, it becomes impossible to progress further in emulators without cheat codes&#47;hacks or by properly emulating the Full Changer.</p>

	<ul>
		<li class="list_item">Zok Zok Heroes (CGB-BZHJ-JPN)</li>
		<li class="list_item">MBC5 + Battery Saves</li>
		<li class="list_item">GBC Only</li>
		<li class="list_item">Comes with 1 Full Changer accessory</li>
		<li class="list_item">Full Changer uses one CR2032</li>
		<li class="list_item">Full Changer presumably contains an accelerometer to detect movement</li>
		<li class="list_item">Full Changer has a series of status lights and blinks&#47;beeps when swung correctly</li>
	</ul>

	<a name="zzh_opr"></a>
	<p class="gray_title">[Full Changer] : Operation</p>

	<ol>
		<li>Grab the Full Changer firmly, holding it by the strap</li>
		<li>Press and release the top button. It should beep and the 3 lights should flash for approximately 5 seconds.</li>
		<li>During those 5 seconds, move the Full Changer to draw the pattern of a &#34;Cosmic Character&#34; e.g. for &#34;Z&#34; start left, move right, stop, move downward and leftward, stop, move right, stop.</li>
		<li>Make sure the Full Changer is always held upright while drawing.</li>
		<li>For each successful movement, the Full Changer will activate another light and beep. Once all three at lit, it beeps a little tune and the data is ready to be sent to the GBC.</li>
		<li>Put the bottom of the Full Changer on top of the GBC, making sure to cover the IR port. The Full Changer has a little plastic guide to make sure everything fits and faces the right direction.</li>
	</ol>

	<a name="zzh_com"></a>
	<p class="gray_title">[Full Changer] : IR Communication</p>

	<p>The Full Changer sends a total of 18 IR pulses (ON then OFF periods) when transmitting data. The length of these pulses varies and determines what values the Full Changer is trying to send. Zok Zok Heroes runs in a couple of loops while the pulse takes place. Each iteration, it increments a counter to get an idea of the overall &#34;delay&#34; it takes for the IR light to turn on then turn off. That counter is then placed in WRAM as a single byte (anything greater than 0xFF causes a timeout) and verified later. In this way, Zok Zok Heroes can view data from the Full Changer as a series of bytes rather than light pulses. These 18 bytes do not appear to have to be especially strict values (e.g. changing them +1 or -1 should still yield the same Bright Hero transformation). The overall data format, if any, is currently unknown, making it difficult to determine what those 18 bytes should be without intercepting an actual transmission from the Full Changer (this could change in the future with more analysis).</p>

	<a name="zzh_cap"></a>
	<p class="gray_title">[Full Changer] : Capturing IR Data</p>

	<p>Below is the disassembled GBZ80 code Zok Zok Heroes uses to grab the 18 bytes:</p>

<code>&#47;&#47;This all happens at ROM Bank 1
&#47;&#47;Wait for IR light to come on (Bit 1 of 0xFF46 goes to zero)
&#47;&#47;D is set to 0xFF, timeout if it reaches zero
DEC D
RET Z
LDH A, (0xFF56)
BIT 1, A
JR NZ, 0xF9

&#47;&#47;E acts as a counter for total number of bytes processed from Full Changer
LD E 0x12
LD HL, 0xD005

&#47;&#47;Wait for IR light to go off (Bit 1 of 0xFF46 goes to one)
LD D, 0x00
CALL 0x575E
	INC D
	RET Z
	LDH A, (0xFF56)
	BIT 1, A
	JR Z, 0xF9
	RET

&#47;&#47;Wait for IR light to go on (Bit 1 of 0xFF46 goes to one)
CALL 0x576C
	INC D
	RET Z
	LDH A, (0xFF56)
	BIT 1, A
	JR NZ, 0xF9
	RET

&#47;&#47;Save results to 0xD005 - 0xD017
LD (HL), D
INC HL
DEC E

&#47;&#47;Jump back to LD, 0x00. Repeat loop until E is zero.
JR NZ, 0xF3</code>

	<p>Once all 18 bytes have been stored in WRAM, it&#39;s possible to read them and save them using a ROM hack. Alternatively, homebrew software can use code with the same timing to accurately capture IR data from the Full Changer.</p>

	<a name="zzh_emu"></a>
	<p class="gray_title">[Full Changer] : Emulation</p>

	<p>The Full Changer can be successfully emulated by setting Bit 1 of RP register (located at 0xFF56) to 0 or 1 at the appropiate times. To do so requires accurate timing and knowing the amount of cycles it takes to generate the delays represented by those 18 bytes in WRAM. When activating the Full Changer, GBE+ always fires the 1st &#34;ON&#34; IR signal at a specific time to get consistent timings:</p>

<code>DEC D
RET Z
LDH A, (0xFF56)

&lt;---- After the CPU reads 0xFF56 and the user activates the Full Changer, IR light is turned on here
&lt;---- This happens after the actual instruction is executed, so the loop runs once more

BIT 1, A
JR NZ, 0xF9</code>

	<p>Afterwards, the timings for ON and OFF pulses can be calculated as such (ALL TIMING IS IN DOUBLE SPEED):</p>

<code>Afterwards, the timings for ON and OFF pulses can be calculated as such (ALL TIMING IS IN DOUBLE SPEED):

1st ON pulse length			74 + (20 * (LENGTH-2))

Every other ON pulse length		78 + (20 * (LENGTH-2))

OFF pulse length			38 + (20 * (LENGTH-2))</code>

	<p>The LENGTH is number of times the CPU register D is incremented at 0x575E or 0x576C. The sum two LENGTHs from one ON pulse and one OFF pulse must be equal to the delay data in WRAM. For example, say the delay data contains 0x30. This means that the TOTAL amount of times D was incremented is 0x30. In a perfect world, the Full Changer would probably turn on the IR light so that D is incremented 0x18 times, then turn off the IR light so that D is incremented again 0x18 times. In reality, however, the length of the ON&#47;OFF pulses could run a bit longer or shorter. As far as Zok Zok Heroes is concerned, the total amount of time the IR light is ON then OFF is what matters, so the ON&#47;OFF pulse timings ultimately have to add up.</p>

	<p>The current database GBE+ uses recreates ON&#47;OFF pulses that generally run for the same amount of cycles. However, based on hardware tests, the ON pulses have variable lengths, while the OFF pulses are typically constant. Again, Zok Zok Heroes won&#39;t care, as long as the total time of the ON&#47;OFF pulses meets whatever value it expects.</p>

	<!-- GBA Screen Stretch -->
	<a name="gss_gen"></a>

	<p class="gray_title">GBA Screen Stretch</p>

	<p>GBA hardware has the ability to stretch the final image drawn on-screen when running DMG or GBC games. On applicable hardware (e.g. not the Micro, original NDS, or NDS Lite models), the L and R triggers toggle this feature on and off respectively. The default mode is to display the DMG&#47;GBC image in the middle of the GBA screen with black borders. The dimensions are as follows:</p>

<code>Top and bottom borders (240x8 pixels, or 30x1 tiles)
Left and right borders (40x160 pixels, or 5x20 tiles)
DMG/GBC screen (160x144 pixels, or 20x18 tiles)</code>

	<p>Technically, the original DMG&#47;GBC screen has an offset of (40, 8). Once the player toggles stretching, the above dimensions change:</p>

<code>Top and bottom borders (240x8 pixels, or 30x1 tiles)
Left and right borders (Not Applicable)
DMG/GBC screen (240x144 pixels, or 30x18 tiles)</code>

	<p>The DMG&#47;GBC screen completely stretches to the left and right ends of the screen. No vertical stretching occurs; the black bars still exist at the top and the bottom. Horizontal stretching follows a simple formula. For every 2 pixels from the original 160x144 image, a third pixel is generated by blending them together. This third pixel is then placed between the two original pixels. For example, imagine Pixel A and Pixel B represent original pixels from the 160x144 image. Pixel C is the result of blending the two of them. The GBA will produce A-C-B when stretching DMG and GBC games.</p>

	<p>This method of stretching acts on the present 160x144 image generated by the DMG/GBC game, that is to say, scrolling the background, window, or OBJs can produce minor inconsistencies depending on where a tile is rendered to the screen. Generally, these inconsistencies affect the blending seen around edges. For example, in the first level of Super Mario Land, the trunks of the trees in the background are only 1 pixel wide. When stretching, the blended edge will switch from the left to the right depending on its current position due to scrolling. However, these inconsistencies are barely visible under the best circumstances, and almost impossible to detect during actual gameplay.</p>

	<p>The blending comes straight from the GBA&#39;s affine transformations. That is to say, after the final DMG&#47;GBC screen is rendered, the GBA controls all output via BG2. Even in the GBA&#39;s DMG&#47;GBC backward compatibility mode, GBA video hardware is still being used to display graphics. Currently, the exact formula for determining colors remains unknown, however, something as simple as averaging Pixel A and Pixel B gives quick, adequately believable results. One thing that is known about the blending: if A and B are the same color, they will not produce a different color.</p>

	<!-- GBC IR -->
	<a name="ir_gen"></a>

	<p class="gray_title">GBC Infrared Communication</p>

	<p>The Game Boy Color came with an infrared port on the very top of the handheld. Previously, where IR communications had to be done with special cartridges (like the HuC-1 variants), the Game Boy itself now had the hardware built-in. Unfortunately, the feature was never popular outside of a few games and accessories. The IR port essentially sends out signals and is also capable of receiving them, allowing for fast, wireless, line-of-sight transmission.</p>

	<ul>
		<li class="list_item">GBC comes with one IR port. Capable of sending and receiving an IR signal (two separate diodes).</li>
		<li class="list_item">Turning on the IR light does drain battery, hence not recommended to leave it on when not in use</li>
		<li class="list_item">IR port can communicate with non-GBC devices, e.g. anything that sends an IR signal (TV remotes, Wiimotes, household lamps, etc)</li>
	</ul>

	<a name="ir_gam"></a>
	<p class="gray_title">[GBC Infrared] : Compatible Games</p>

	<p>This list represents all the games that have been verified to use the IR port. While exhaustive, this list is probably not complete. Some &#34;Ubi Key&#34; games have not been confirmed (Hype: The Time Quest, Inspector Gadget), and there are likely more Japanese exclusives that need to be added. It&#39;s dubious whether or not Animorphs actually is a &#34;Ubi Key&#34; game. The back boxart doesn&#39;t have the &#34;IR Compatible&#34; logo, and the manual makes no mention of IR communication.</p>

	<ul>
		<li class="list_tab"><div class="x">Bomberman Max: Blue Champion</div><div class="y">Combine Charaboms&#47;Trade completed levels&#47;Unlock hidden areas</div></li>
		<li class="list_tab"><div class="x">Bomberman Max: Red Challenger</div><div class="y">Combine Charaboms&#47;Trade completed levels&#47;Unlock hidden areas</div></li>
		<li class="list_tab"><div class="x">Carl Lewis Alhletics 2000</div><div class="y">Ubi Key</div></li>
		<li class="list_tab"><div class="x">Chee-Chai Alien</div><div class="y">Enhances IR sensor to detect artificial light sources. Catch&#47;trade Chaliens</div></li>
		<li class="list_tab"><div class="x">Dancing Furby</div><div class="y">Sends signal to Furby doll, Furby reacts based on dance performance</div></li>
		<li class="list_tab"><div class="x">Donkey Kong Country</div><div class="y">Transfer pictures to stickerbook</div></li>
		<li class="list_tab"><div class="x">Harry Potter and the Sorceror&#39;s Stone</div><div class="y">Trade &#34;Famous Witches and Wizards&#34; cards</div></li>
		<li class="list_tab"><div class="x">Harry Potter and the Chamber of Secrets</div><div class="y">Trade &#34;Famous Witches and Wizards&#34; cards</div></li>
		<li class="list_tab"><div class="x">Mary-Kate and Ashley Pocket Planner</div><div class="y">Send and receive &#34;G-mail&#34; messages</div></li>
		<li class="list_tab"><div class="x">Mickey&#39;s Racing Adventure</div><div class="y">Send and receive messages. Unlocks ??? in Mickey&#39;s Speedway USA</div></li>
		<li class="list_tab"><div class="x">Mickey&#39;s Speedway USA</div><div class="y">???</div></li>
		<li class="list_tab"><div class="x">Mission Impossible</div><div class="y">Send and receive messages, notes, addresses + custom TV remote</div></li>
		<li class="list_tab"><div class="x">Papyrus</div><div class="y">Ubi Key</div></li>
		<li class="list_tab"><div class="x">Perfect Dark</div><div class="y">Trade multiplayer maps and other unlockables</div></li>
		<li class="list_tab"><div class="x">Playmobil Interactive: Laura</div><div class="y">Ubi Key</div></li>
		<li class="list_tab"><div class="x">Pokemon Pinball</div><div class="y">Trade/combine Top Scores</div></li>
		<li class="list_tab"><div class="x">Pokemon Gold</div><div class="y">Mystery Gift + Send trainer data to Viridian City Trainer House</div></li>
		<li class="list_tab"><div class="x">Pokemon Silver</div><div class="y">Mystery Gift + Send trainer data to Viridian City Trainer House</div></li>
		<li class="list_tab"><div class="x">Pokemon Crystal</div><div class="y">Mystery Gift + Send trainer data to Viridian City Trainer House</div></li>
		<li class="list_tab"><div class="x">Pokemon Trading Card Game</div><div class="y">&#34;Card Pop&#34; to generate random cards. Trade individual cards. Trade deck configurations</div></li>
		<li class="list_tab"><div class="x">Pokemon Card GB2: Here Comes Team GR!</div><div class="y"> &#34;Card Pop&#34; to generate random cards. Trade individual cards. Trade deck configurations</div></li>
		<li class="list_tab"><div class="x">Rayman</div><div class="y">Ubi Key</div></li>
		<li class="list_tab"><div class="x">The Road to El Dorado</div><div class="y">Ubi Key</div></li>
		<li class="list_tab"><div class="x">Sakura Taisen GB</div><div class="y"> Send step-based &#34;Points&#34; to GBC from Pocket Sakura, or between two GBCs</div></li>
		<li class="list_tab"><div class="x">Super Mario Bros. DX</div><div class="y">Trade/combine Top Scores</div></li>
		<li class="list_tab"><div class="x">Toonsylvania</div><div class="y">Ubi Key</div></li>
		<li class="list_tab"><div class="x">Warlocked</div><div class="y">Trade wizards</div></li>
		<li class="list_tab"><div class="x">Zok Zok Heroes</div><div class="y">Transmit &#34;Cosmic Characters&#34; from Full Changer accessory to transform hero</div></li>
	</ul>		

	<a name="ir_typ"></a>
	<p class="gray_title">[GBC Infrared] : Communication Types</p>

	<p>While a number of games may use similar formats for their IR communications, there is no &#34;standard&#34; protocol that all games use. IR communication is entirely determined by the game&#39;s code, hence it can vary wildly depending on needs. However, all communications fall into one of several general categories as described below:</p>

	<ul>
		<li><strong>1-Player Init:</strong> These only require one GBC to initiate IR transfers. Both GBCs typically wait for an infrared signal. When one player presses a button, the GBC starts sending pulses. This setup is not unlike how 2-Player Serial I&#47;O is handled (with master and slave Game Boys). Examples include Super Mario Bros. DX score exchange and the GBC-to-GBC Mystery Gifts in Pokemon Gold&#47;Silver&#47;Crystal. Most IR compatible games fall into this group.</li>

		<li><strong>2-Player Init:</strong> Transfers require both GBCs to initiate at roughly the same time. Examples include Pokemon Pinball score exchange, Pokemon TCG&#39;s &#34;Card Pop&#34;, and trading&#47;fighting Charaboms in the Bomberman games.</li>

		<li><strong>Active Object Init:</strong> Transfers require the GBC to interact with another non-GBC device capable of both sending and receiving infrared signals. These objects are designed to work specifically with GBCs and send pulses in much the same manner as a GBC would. Examples include Mystery Gifts via the Pokemon Pikachu 2 and trading Points via the Pocket Sakura.</li>

		<li><strong>Inactive Object Init:</strong> Transfers require the GBC to interact with another non-GBC device capable of sending infrared signals but not necessarily receiving them. These objects may not be designed to work specifically with GBCs (notable exception is the Full Changer). Communication is input-only for these cases. Examples include Zok Zok Heroes, Chee Chai Alien, the Bomberman Max games&#39; special stages, and Mission Impossible&#39;s TV remote feature.</li>
	</ul>

	<a name="ir_pro"></a>
	<p class="gray_title">[GBC Infrared] : Communication Protocol</p>

	<p>Again, there is no set or established infrared protocol that games must follow. Many games vary in their approach. For example, the 2nd Generation Pokemon games use the GBC&#39;s hardware timers, while others have hardcoded values that count cycles to check timing. The simplest form is a barebones communication protocol, i.e. something like a binary Morse code where a &#34;0&#34; is a long ON-OFF pulse and &#34;1&#34; is a short ON-OFF pulse or vice versa. Properly done, data could have been short, compact, and easily converted into bytes in RAM. Sakura Taisen GB seems to follow this model in its communications with the Pocket Sakura. Not all games do this, however, and appear to be doing who knows that, opting instead for customized and specialized communications unique to each title. To illustrate this idea, it would be possible to use a table of given lengths of IR ON-OFF pulses so that individual bytes could be sent all at once instead of in a binary, bit-by-bit manner. A number of games try to send a few pulses when pressing input like the A button and wait for another GBC to echo that in response, but after the handshake, most of the IR pulses are impossible to understand without disassembling the code.</p>

	<p>One thing to note is that 4 games in particular do share somewhat similar IR protocols, at least in regards to the initial handshake between 2 GBCs. They are Pokemon TCG 1 & 2 and Bombermax Red & Blue, all from the &#34;2-Player Init&#34; category above. Typically, IR capable GBC games will continually wait for an IR signal on both sides, i.e. the &#34;1-Player Init&#34; category. When one player presses certain input, that GBC takes the initiative and sends out a few IR pulses. That is to say, for most IR games, it only takes *just one* player to start the entire process.</p>

	<p>The handshake for the 4 games previously mentioned, however, requires *both* players to input at almost the same time. One has to be slightly faster or slower than the other. Each side continually sends a few IR pulses, then reads the sensor to see if anything was received. If so, the GBCs begin to sync. The idea is that one side should be sending while the other is checking, and then the handshake completes. This is why one side needs to be faster or slower to input; if they are sending IR signals at the same time, they don&#39;t see anything when reading the sensor. As a result, both GBCs cannot input at exactly the same time. Practically speaking, this is unlikely to happen under normal circumstances, since most humans can&#39;t synchronize their actions down to a handful of microseconds, so the handshake will normally succeed.</p>

	<p>The following is just theory. This handshake is possibly an artifact of the HuC-1. Consider that the Japanese version of Pokemon TCG 1 used the HuC-1 for its IR communications, and the developers may have borrowed the &#34;best practices&#34; used by other HuC-1/&#34;GB KISS&#34; games. When bringing Pokemon TCG 1 overseas, the IR handling code was likely minimally adapted to use the GBC&#39;s IR port, with the underlying protocol remaining unchanged in most regards. Pokemon TCG 2 ditched the HuC-1 in favor of the GBC IR port, so the IR code from non-Japanese versions of Pokemon TCG 1 was copy+pasted. The Bomberman games were made by Hudson Soft, literally the same people who created the HuC-1 in the first place. They too probably used the same protocol that had worked forever in their &#34;GB KISS&#34; games, so they used the same handshake method as before, just on the GBC IR port now. More research into the HuC-1 itself and the games needs to be done to confirm any of this.</p>

	<a name="ir_reg"></a>
	<p class="gray_title">[GBC Infrared] : RP Register</p>

	<p>On the GBC, the MMIO register located at 0xFF56 controls infrared communication. Simply known as &#34;RP&#34; (Radiation Port? Reception Port? Red Port???), it is responsible for sending and receiving IR signals. Below is a diagram of the 8-bit register:</p>

<code>Bit 0:		Turn IR light ON (1) or OFF (0)					(R&#47;W)
Bit 1:		IR signal (0 = Receiving signal) (1 = Normal&#47;No signal)		(R)
Bits 2-5:	Unused
Bits 6-7:	Signal Read Enable (0 = Disable) (3 = Enable)			(R&#47;W)</code>

	<p>Turning on the IR light is as simple as writing to Bit 0 of RP. Reading is a bit more complicated. Bits 6 and 7 must both be set (0xC0), to read Bit 1, otherwise Bit 1 returns 1, acting as if no signal is detected, except in edge cases detailed below in &#34;Obscure Behavior&#34;. With signal reading enabled, Bit 1 will determine the status of any incoming IR signals. Like other Game Boy MMIO registers, unused bits read high (set to 1).</p>

	<a name="ir_fad"></a>
	<p class="gray_title">[GBC Infrared] : Signal Fade</p>

	<p>The IR sensor in the GBC adapts to the current level of IR light. That is to say, if the GBC receives a sustained IR signal beyond a certain amount of time, eventually the sensor treats this as a new &#34;normal&#34; level of IR light, and Bit 1 of RP goes back to 1. This is called the signal &#34;fade&#34; because it may appear as if the signal disappears.</p>

	<p>Signal fade time is dependent on length and has an inverse relationship with the distance between a GBC and the IR light. The closer a GBC is to the IR source, the longer the fade time. The farther away a GBC is to the IR source, the shorter the fade time. One possible explanation for everything is that the IR signal is weaker on the receiving end, so the signal is prone to get &#34;lost&#34; to surrounding noise. The GBC IR sensor is probably good at sending IR signals (evidenced by the Mission Impossible cheat to turn a GBC into a TV remote) but not so good at picking up signals (evidenced by Chee Chai Aliens plastic add-on to enhance IR reception).</p>

	<p>At about 3.0 to 3.5 inches (7.62 to 8.89cm) signal fade time appears to be around 3ms. Optimal distance seems to be 2.5 to 4.0 inches (6.35 to 10.16cm) to maintain a fade time close to 3ms and avoid potential miscommunication. One oddity of note is that putting two GBCs very close together (physically touching) produced unusually short fade times, far shorter than 3ms. There may be some sort of interference at that range.</p>

	<a name="ir_obs"></a>
	<p class="gray_title">[GBC Infrared] : Obscure Behavior</p>

	<p>The RP register has one very strange quirk. Disabling Bits 6 and 7 and then subsequently re-enabling them causes Bit 1 to go to zero under certain conditions. In other words, the IR sensor will act as if it is detecting a signal if reading the signal is disabled then enabled. It seems this behavior happens in the presence of any light; covering up the sensor during the read signal disable&#47;enable causes the sensor to act normally. It&#39;s possible that the sensor resets itself (to its lowest level of detection???) and immediately detects any infrared sources, even from ambient&#47;environmental light. The presence of any noise may temporarily trick the sensor into &#34;seeing&#34; IR light. By abusing this behavior, the GBC has some rudimentary ability to gauge the type of nearby lighting:</p>

<code>--------------------------------------------------------------------------------------------
Result of 1st RP Write (0x00)	Result of 2nd RP Write (0xC0)	Type of Lighting	
--------------------------------------------------------------------------------------------
Bit 1 = 1			Bit 1 = 1			Dark
Bit 1 = 0			Bit 1 = 1			Ambient
Bit 1 = 0 (sometimes 1)		Bit 1 = 0			Bright</code>

	<p>Writing 0x00 to RP, followed by 0xC0 will trigger these results listed above. One very important thing to note is that when enabling Bits 6 and 7 (writing 0xC0), it does take some time for the sensor to register legitimate IR light coming into the sensor. I.e. if you want to use this method to detect what kind of light a GBC is looking at, the software needs to loop for a bit until Bit 1 of RP changes. Generally a few hundred cycles in double-speed mode will suffice. If Bit 1 of RP remains 1 after the loop, it&#39;s safe to assume the lighting is either ambient or dark. This delay doesn&#39;t seem to happen when Bits 6 and 7 are never disabled (which is what most official GBC software does). Games typically write either 0xC0 or 0xC1 to RP, with a small handful setting it to 0x00 initially when setting up other MMIO registers (Pokemon G&#47;S&#47;C does this).</p>

	<p>The downside to this method is that when detecting a bright IR source, the sensor quickly adjusts to this new level, and the next attempt at writing 0x00 followed by 0xC0 to RP will result in readings of dark or ambient (typically dark though). Essentially the bright result only appears briefly when transitioning from lower levels of light, then it &#34;disappears&#34; thanks to the short time it takes for IR signal fade. Designing a game mechanic (darkness and light) around this quirk is still possible, although it would require careful thought and planning to properly work around the observed limitations.</p>

	<p>One suggested method: once the Bright setting is detected, switch to writing only 0xC0 to RP so that the IR sensor works normally. If IR light stops being detected, switch to alternating 0x00 and 0xC0 writes as described above to determine Dark or Ambient settings. Whether it&#39;s practical or not to do this in a game remains theoretical at this point.</p>

	<a name="ir_pp2"></a>
	<p class="gray_title">[GBC Infrared] : Pokemon Pikachu 2</p>

	<p>The Pokemon Pikachu 2 (PP2) is a virtual pet device similar in concept to Tamagotchis. The PP2 is the successor to the original Pokemon Pikachu with a number of notable changes, largely the new color screen and the ability to communicate with Pokemon Gold, Silver, and Crystal via IR signals. These signals are used for the Mystery Gift functionality. Unlike normal Mystery Gifts between two GBCs, which produce random items, the PP2 gives out consistent items based on the number of &#34;watts&#34; transferred. The &#34;watts&#34; are the PP2&#39;s form of currency generated by the unit&#39;s pedometer (via walking, or more commonly, just shaking). Players either give Pikachu watts to make it happy, or send them to another PP2, or use them to Mystery Gift with Pokemon G&#47;S&#47;C.</p>

	<p>In addition to giving out predictable items via Mystery Gift, the PP2 can also Mystery Gift without time limits. Normally, when two GBCs Mystery Gift 5 times in Pokemon G&#47;S&#47;C, players have to wait until the following day to try again. No such restriction applies when a GBC communicates with the PP2. The two can Mystery Gift endlessly, as long as the PP2 has watts to transfer. Below is a table of watts and the items they generate:</p>

<code>0 - 99 Watts		Eon Mail
100 - 199 Watts		Berry
200 - 299 Watts		Bitter Berry
300 - 399 Watts		Great Ball
400 - 499 Watts		Max Repel
500 - 599 Watts		Ether
600 - 699 Watts		Miracle Berry
700 - 799 Watts		Gold Berry
800 - 899 Watts		Elixir
900 - 998 Watts		Revive
999 Watts		Rare Candy</code>

	<p>Current analysis of the IR communications between a GBC and a PP2 indicates that the PP2 interacts with Pokemon Crystal differently in comparison to Pokemon Gold and Silver. Each transfer appears to be 2007 ON-OFF transitions long.</p>

	<a name="ir_sak"></a>
	<p class="gray_title">[GBC Infrared] : Pocket Sakura</p>

	<p>The Pocket Sakura is another virtual pet device similar to the Pokemon Pikachu 2. Design-wise, it is a copy+paste version of the PP2, except it&#39;s pink. Interestingly enough, the Pocket Sakura was made by Media Factory, the same people behind Zok Zok Heroes and the Full Changer device. The Pocket Sakura uses a pedometer to make Sakura travel to various locations and meet other Sakura Taisen-based characters. When resting at a location, the pedometer turns steps into &#34;points&#34; (10 steps = 1 point), which can then be sent to a GBC running Sakura Taisen GB or another Pocket Sakura.</p>

	<p>Each transfer appears to be 1607 ON-OFF transitions long.</p>

	<!-- Pocket Sonar -->

	<a name="ps_gen"></a>
	<p class="gray_title">[Pocket Sonar] : General Hardware Information</p>

	<p>Gyogun Tanchiki: Pocket Sonar (shortened to just Pocket Sonar) was a combination &#34;game&#34; and accessory released by Bandai on July 24, 1998 exclusively in Japan. The cart and attached sonar device act as a fish finder, capable of probing water depths of up to 20 meters. It was the first video-game based sonar hardware, but not the last (Bandai released the WonderSwan Handy Sonar the following year).</p>

	<ul>
		<li class="list_item">Comes in a long, bulky blue cartridge.</li>
		<li class="list_item">Requires 4 AAA batteries to work, has ON&#47;OFF switch + light.</li>
		<li class="list_item">Sonar device attaches via a 3.5mm jack inside the cartridge.</li>
		<li class="list_item">Sonar device has a super long cord, with yellow foam around the actual audio hardware.</li>
		<li class="list_item">Manual says operating tempurature range (使用温度範囲) is between 5C and 50C (no ice fishing, do not use in a hot spring).</li>
		<li class="list_item">Cartridge uses the MBC1S, virtually identical to the MBC1, but has sonar capabilities built-in.</li>
		<li class="list_item">Capable of probing depths of 20m.</li>
		<li class="list_item">Internally, MBC1S is two PCBs (MBC and sonar) linked together by 5 soldered wires.</li>
	</ul>

	<a name="ps_mbc"></a>
	<p class="gray_title">[Pocket Sonar] : MBC1S</p>

	<p>The MBC1S is a specialized variant of the standard MBC1. The key difference here is that the ability to control sonar hardware was added. Aside from that, the MBC1S appears largely identical to the MBC1 from a high-level view. Below are the MBC registers:</p>

<code>0x0000 - 0x1FFF (W)	:	Unknown. Not used in the Pocket Sonar. Pocket Sonar has no cart RAM.

0x2000 - 0x3FFF (W)	:	ROM Bank Number. Same as MBC1.

0x4000 - 0x5FFF	(W)	:	Sonar Pulse. Apparently activates the sonar when writing &#34;1&#34;, turns it off when writing &#34;0&#34;. Must be in &#34;sonar mode&#34;

0x6000 - 0x7FFF	(W)	:	Sonar Mode Enable&#47;Disable. Activates &#34;sonar mode&#34; when writing &#34;1&#34;. Pocket Sonar never seems to write &#34;0&#34; here though.

0xA000		(R)	:	Sonar Data. Data comes in byte-by-byte and the software uses that information to build an image of what&#39;s in the water.</code>

	<p>The Pocket Sonar doesn&#39;t have cartridge-based RAM, so it repurposes most MBC1 registers dealing with RAM to instead handle sonar.</p>

	<a name="ps_fmt"></a>
	<p class="gray_title">[Pocket Sonar] : Sonar Format</p>

	<p>The Pocket Sonar displays a 160x96 image on screen based on sonar data. This &#34;frame&#34; is constantly updated, albeit quite slowly. The next frame slides in from the right to replace the old one. Each frame is generated using the responses that come from reading 0xA000. The byte held in this register determines what color the software should draw on-screen, and the colors ultimately represent either open water or soil, sediment, rocks, and other solid flooring. The Pocket Sonar interprets two different &#34;sets&#34; of colors, one for before solid flooring is detected, and one for after. With Shade 0 being the lightest DMG pixel color and Shade 3 being the darkest DMG pixel color, the following values held in 0xA000 determine the corresponding colors:</p>

<code>---------------------------------------------------------
VAL = 0xA000 AND 0x7 : Before solid flooring detected (0xA000 reads 0x00)
---------------------------------------------------------
1		SHADE 3		Solid object or debris (the top-most exterior)
2, 3		SHADE 2		Solid object or debris (inner layers)
4, 5, 6, 7	SHADE 0		Open water

---------------------------------------------------------
VAL = 0xA000 AND 0x7 : After solid flooring detected (0xA000 reads 0x00)
---------------------------------------------------------
0, 1, 2, 3	SHADE 3		Solid floor (the top-most exterior)
4, 5, 6, 7	SHADE 1		Solid floor (inner layers)</code>

	<p>Solid floor detections appears to happen after the Pocket Sonar returns a single 0x00 byte for each section of the frame. Every frame is internally divided into 1x96 strips by the software. Depending on the depth the Pocket Sonar is trying to probe (e.g. 2m, 5m, 10m, etc), the device reads 0xA000 more frequently.</p>

<code>---------------------------------------------------------
Depth		1x96 Reads		Total Frame Reads
---------------------------------------------------------
2 meters	188			30080
5 meters	196			31360
10 meters	198			31680
15 meters	199.4			31904
20 meters	199			31840
30 meters	200			32000</code>

	<p>The first 96 reads correspond directly to a 1x96 strip that&#39;s part of the larger 160x96 frame. That is to say, 1 read = 1 pixel drawn on-screen (after the waterline). The additional reads from 0xA000 are not drawn unless the magnification feature is used. With magnification, instead of displaying the sonar image from the waterline to the probing depth (e.g. 0-2m, 0-5m, 0-10m), the Pocket Sonar will start drawing at halfway to the probing depth (e.g. 1-2m, 2.5-5m, 5-10m). It effectively drops viewport of the sonar image, and in doing so displays some of the other reads beyond the first 96. Consequently, using the magnification feature changes the above chart to this:</p>

<code>-----------------------------------------------------------------
Depth			1x96 Reads		Total Frame Reads
-----------------------------------------------------------------
1.0 - 2.0 meters	176			28160
2.5 - 5.0 meters	192			30720
5.0 - 10.0 meters	196			31360
7.5 - 15.0 meters	198			31680
10.0 - 20.0 meters	198			31680
20.0 - 30.0 meters	199			31840</code>

	<p>The Pocket Sonar represents the waterline as all black and forcibly draws a certain number of pixels for it depending on the depth the device is checking. The waterline is not applicable when using magnification. Apparently the Pocket Sonar internally divides the 160x96 frame into a 80x96 &#34;sub-frame&#34;. It isn&#39;t clear what the purpose of this is, but it appears to be some sort of mid-frame reset if necessary, perhaps if garbage values are detected (e.g. sonar data that doesn&#39;t realistically make sense?)</p>

	<p>To collect the above sonar data, the MBC1S must first send out a sonar pulse by writing &#34;1&#34; then &#34;0&#34; to the memory regions 0x4000 - 0x5FFF. Afterwards, 0xA000 will hold a single byte representing part of the sonar image. The process of reading back the sonar image appears to take some time, however. It doesn&#39;t seem to be immediate, as the Pocket Sonar&#39;s software reads 0xA000 across several screen refreshes. Below are charts detailing the number of 0xA000 reads per-screen refresh on the Game Boy LCD:</p>

<code>-------------------------------------------------------------
2 Meters	Magnification OFF	Magnification ON
-------------------------------------------------------------
Refresh_0	188 reads		176 reads
Refresh_1	0 reads			0 reads
Refresh_2	0 reads			0 reads
Refresh_3	0 reads			0 reads
Refresh_4	0 reads			0 reads
Refresh_5	0 reads			0 reads
Refresh_6	0 reads			0 reads
Refresh_7	0 reads			0 reads

-------------------------------------------------------------
5 Meters	Magnification OFF	Magnification ON
-------------------------------------------------------------
Refresh_0	153 or 154 reads	192 reads
Refresh_1	42 or 43 reads		0 reads		
Refresh_2	0 reads			0 reads
Refresh_3	0 reads			0 reads
Refresh_4	0 reads			0 reads
Refresh_5	0 reads			0 reads
Refresh_6	0 reads			0 reads
Refresh_7	0 reads			0 reads
Refresh_8	0 reads

-------------------------------------------------------------
10 Meters	Magnification OFF	Magnification ON
-------------------------------------------------------------
Refresh_0	76 reads		135 or 137 reads
Refresh_1	121 reads		59 or 61 reads
Refresh_2	1 read			0 reads
Refresh_3	0 reads			0 reads
Refresh_4	0 reads			0 reads
Refresh_5	0 reads			0 reads
Refresh_6	0 reads			0 reads
Refresh_7	0 reads			0 reads
Refresh_8	0 reads			0 reads
Refresh_9	0 reads

-------------------------------------------------------------
15 Meters	Magnification OFF	Magnification ON
-------------------------------------------------------------
Refresh_0	50 reads		90 or 92 reads
Refresh_1	81 reads		106 or 108 reads
Refresh_2	68 reads		0 reads
Refresh_3	0 reads			0 reads
Refresh_4	0 reads			0 reads
Refresh_5	0 reads			0 reads
Refresh_6	0 reads			0 reads
Refresh_7	0 reads			0 reads
Refresh_8	0 reads			0 reads
Refresh_9	0 reads

-------------------------------------------------------------
20 Meters	Magnification OFF	Magnification ON
-------------------------------------------------------------
Refresh_0	37 reads		68 or 69 reads
Refresh_1	60 reads		109 reads
Refresh_2	59 or 60 reads		20 or 21 reads
Refresh_3	42 or 43 reads		0 reads
Refresh_4	0 reads			0 reads
Refresh_5	0 reads			0 reads
Refresh_6	0 reads			0 reads
Refresh_7	0 reads			0 reads
Refresh_8	0 reads			0 reads
Refresh_9	0 reads			0 reads
Refresh_10	0 reads

-------------------------------------------------------------
30 Meters	Magnification OFF	Magnification ON
-------------------------------------------------------------
Refresh_0	24 reads		45 or 46 reads
Refresh_1	40 reads		73 reads
Refresh_2	41 reads		73 reads
Refresh_3	40 reads		7 or 8 reads
Refresh_4	40 reads		0 reads
Refresh_5	15 reads		0 reads
Refresh_6	0 reads			0 reads
Refresh_7	0 reads			0 reads
Refresh_8	0 reads			0 reads
Refresh_8	0 reads			0 reads
Refresh_10	0 reads			0 reads
Refresh_11	0 reads
Refresh_12	0 reads</code>

	<p>The values above should be considered approximate. When changing between different depths, the above numbers get slightly messed up for a short time (usually just for 1 sonar pulse) before they normalize. During the transition, the totals still add up (e.g. 10m still reads 0xA000 198 times per 1x96 segment of the frame, with magnification off), however, the spacing between reads shifts a bit. Trying to change 30m to the next depth (pressing A on the depth change menu item) sometimes causes an elongated pause between sonar pulses (31 LCD refreshes, so more than 1&#47;2 a second) but since 30m is the max, the Pocket Sonar keeps reading 0xA000 at 200 times per 1x96 frame segment. The numbers briefly fluctuate across screen refreshes until returning to the chart above.</p>

	<a name="ps_fsh"></a>
	<p class="gray_title">[Pocket Sonar] : Fish Finder</p>
	
	<p>The usefulness of the Pocket Sonar, aside from bathymetry, is largely its fish finding capabilities. The Pocket Sonar has a toggable option for displaying any fish it believes it has detected. The fish are represented by simple 8x8 graphics. Strangely enough, the fish are aligned to a slightly different grid than the 160x96 sonar image. If using the 160x96 sonar image divided into 8x8 cells as a reference, the fish are drawn over this image with a Y offset of -1. This &#34;fish grid&#34; also determines when the Pocket Sonar software thinks it has located a fish.</p>

	<p>Fish tiles are always aligned on the X-axis by 8 pixels of the &#34;fish grid&#34;, so they are always locked into columns, however, they seem to shift freely on the Y-axis. Obviously, fish are only detected in open water; once solid flooring (and not just debris or other objects) has been detected, no fish appear below the floor. As such, fish detection only happens when using the first &#34;set&#34; of colors for drawing the frame. To detect fish, an 8x8 section of the &#34;fish grid&#34; needs to have only 1 value of 0x00 or 0x01 within the first column. If not, the Pocket Sonar will treat it as a miscellaneous object. Even if the second column (or every other one) has multiple 0x00 or 0x01 values, the Pocket Sonar only cares about first column. The first occurence of a 0x00 or 0x01 value in the first column of any 8x8 cell on the &#34;fish grid&#34; appears to determine where the fish tile is aligned vertically.</p>

	<p>Oddly enough, several options change the X offset of the &#34;fish grid&#34;. Enabling or disabling the option for displaying fish seems to reposition the &#34;fish grid&#34; according to whatever 1x96 segment of the frame is rendered. Additionally, toggling magnifcation or the &#34;auto&#34; (オート) mode resets the &#34;fish grid&#34;.</p>

	<a name="ps_gbi"></a>
	<p class="gray_title">[Pocket Sonar] : Game Boy Incompatibilities</p>

	<p>For some reason, Game Boy Color and Game Boy Advance units do not work with the Pocket Sonar. These handhelds seem to return 0x00 when reading 0xA000 for the sonar. When the sonar is turned on, this results in a pure black screen. When the sonar is turned off, some other value (probably 0xFF) is read, resulting in a pure white screen. DMG and MGB Game Boys have no apparent trouble properly reading sonar data from 0xA000 though.</p>

	<a name="ps_rsc"></a>
	<p class="gray_title">[Pocket Sonar] : Further Research</p>

	<p>There are a couple of uncertainties that require further research to clarify. The Pocket Sonar displays a brief &#34;demo&#34; mode if players wait around the title screen. It shows an example sonar image scrolling across the screen, however it uses 3 shades to represent the ground (SHADE 3, SHADE 2, and SHADE 1 in that order). It doesn&#39;t seem possible to recreate this type of image when actually using the Pocket Sonar, as the ground only uses 2 shades (SHADE 3 and SHADE 1). Additionally, on the box and in the manual, all pictures of the Pocket Sonar in action only show these 2 shades. Extensive testing using various values for the sonar image data at 0xA000 could not reproduce the &#34;demo&#34; mode either. While the &#34;demo&#34; mode may be impossible on real hardware, actual tests in real bodies of water need to be done to ultimately verify this behavior.</p>

	<p>Additionally, while the Pocket Sonar clearly states it can probe a depth of 20m, the software has settings for 30m. It isn&#39;t clear if the Pocket Sonar is capable of handling 30m without issue or if it can do 30m with some degree of inaccuracy. Again, real world testing would have to be done to determine the exact nature of the 30m setting.</p>

</html>					