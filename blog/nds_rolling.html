<!DOCTYPE HTML>
<html>
	<head>
		<title>NDS Stuff</title>
		<link rel="stylesheet" type="text/css" href="./../main.css" />
	</head>

	<body>

		<!-- Main Header -->
		<div class="header">

			<!-- Left Header -->
			<div class="header_left">
				<div class="header_text"><strong>Shonumi</strong></div>
			</div>
		
			<!-- Right Header -->
			<div class="header_right">
				<a class="header_link" href="../downloads.html">Downloads</a>
				<a class="header_link" href="../articles.html">Articles</a>
				<a class="header_link_current" href="../blog.html">Blog</a>
				<a class="header_link" href="../index.html">Main</a>
			</div>

		</div>

		<!-- Main Page Outer Box -->
		<div class="box_outer">
			
			<!-- Main Page Inner Box -->
			<div class="box_inner">

				<div class="center_headline">NDS Stuff</div>
				<div class="headline_underline">. . . . . . . . . . .</div>

				<p class="inner_text_large"><strong>March 18, 2019</strong></p>

				<p class="inner_text">As I have said before, this rolling blog is NOT dead. In fact, it&#39;s about to get super NOT dead from now on. Previously, my biggest achievement was getting some demo software to run in GBE+. It was the first professionally developed software to run in my emulator. I felt really good about that progress, but I still hit a wall. I never got around to perfecting that Z-buffer I talked about (it works, kinda sorta, but needs more love) and I was still stuck basically. I did work on some more <a href="https://github.com/shonumi/gbe-plus-nds-tests">NDS hardware tests</a>, but I still wasn&#39;t booting retail games. Black screen. Black screen. BLACK SCREEN! That&#39;s all GBE+ ever showed.</p>

				<p class="inner_text">Having seen the same stupid, blank screen for years, it gets really demotivating despite all the work I&#39;ve put into GBE+, like I&#39;m not good enough of a programmer to fix it or something. I&#39;d rather work on something that gives me results, as in graphical output. Results feel good. They&#39;re progress, a reward for all the code spent carefully writing, a pat on the back for all the studying and research it takes to make an emulator function. It&#39;s quite simply positive feedback. Without that, I just didn&#39;t feel like dedicating time to NDS emulation when it kept shutting me down. However, I also am loathe to give up such a personally important goal. So every now and then I take a crack at booting commercial NDS titles.</p>

				<p class="inner_text">I had long assumed that there was something not quite right about the way I emulated the way the NDS interfaces with the game ROM. Unlike the Game Boys, the NDS doesn&#39;t readily map the ROM to addressable memory. During boot, it can pre-load some data (up to a few megabytes total) from the ROM for the ARM9 and ARM7 CPUs, but accessing additional ROM data involves sending commands via a SPI bus and copy+pasting a handful of bytes at a time to RAM. It&#39;s not too complicated, but I had no good way of testing if my implementation was correct or not. The best I could do is compare debugging output from another emulator with GBE+. That&#39;s easy enough since I keep a copy of Desmume I modified just for debug logs, but I also needed a test case that did not make extensive use of this ROM interface, to keep the amount of data I needed to analyze to a minimum.</p>

				<p class="inner_text">I turned to Game and Watch Collection. It&#39;s like 1.3MB total for the relevant ROM data (the padding can be ignored altogether). Unlike the demos, which shove all of their data into RAM via that pre-loading method, Game and Watch Collection used the ROM streaming interface. This made it a perfect test case. I compared GBE+&#39;s results to Desmume&#39;s and I found that I was making a silly &#34;off-by-one&#34; error in the ROM transfer lengths. They were 4 bytes too short, terminating before the game logic expected, thus launching it into a perpetual loop where it halted and froze, ultimately giving me that evil, vile black screen of despair. I also messed up ARM7 hardware timers thanks to a typo. Also forgot to add a line of code some time ago for the chip ID used for NDS game carts. Fixing all 3 issues suddenly gave me this:</p>

				<p class="center_img">
					<img class="space_img" src="ndsr_2.png" alt="SUCCESS!" />
				</p>

				<p class="inner_text">Yes, that&#39;s right! An error screen! A glorious, wonderful, unparalleled error screen! Who cares if means some save data stuff isn&#39;t emulated correctly? It&#39;s not an entirely black screen, it&#39;s not blank. It&#39;s <strong>graphical output</strong>. Getting that far meant I was on the right path, more right than I&#39;d ever been so far in my journey. I wondered what other games would run or boot in GBE+. To my surprise, Digimon World Dusk and Guilty Gear: Dust Strikers started showing me screens as well. Digimon even went in-game with a few more adjustments. And with some more work on game saves, I got Game and Watch Collection to boot and go in-game. Guilty Gear still need better save support, but I have the foundations all set.</p>

				<p class="center_img">
					<img class="space_img" src="ndsr_3.png" alt="This is" />
					<img class="space_img" src="ndsr_4.png" alt="what I have been" />
					<img class="space_img" src="ndsr_5.png" alt="WAITING FOR!" />
				</p>

				<p class="inner_text">I&#39;m 110% excited. This is the moment I&#39;ve wanted for a <em>loooooong</em> time. Now I finally made it. I can only go up from here, and I&#39;m very much looking forward to working on NDS emulation more and more from now on.</p>

				<p class="inner_text_large"><strong>November 20, 2018</strong></p>

				<p class="inner_text">This rolling blog is NOT dead. Just got sidetracked between 70+ hours of Octopath Traveler and reverse-engineering Mobile Adapter GB games. The Mobile Adapter was a &#34;must finish by end of year&#34; kinda project, at least as far as supporting internal servers for two games. Man, that took a <strong>ton</strong> of time and energy, and left no space in my life for all things NDS emulation related. Also, been kinda bummed out that after 4 years of starting GBE+, no professionally developed software actually ran in the NDS core. Seeing something that Nintendo made themselves boot up in your own emulator has proven elusive for me. Well, until last week that is. Some demo software is running in GBE+&#39;s NDS core. Finally, something besides homebrew works! Had a number of errors in the 2D graphics engine, minor oversights that led to a handful of glitches. My experimental branch dealing with better NDS timings didn't prove as useful as I&#39;d hoped; there are still a bunch of things GBE+ just isn&#39;t getting right. But, I&#39;m super excited to start moving away from homebrew, even just a little!</p>

				<p class="inner_text">I&#39;ve started a repo of GitHub for NDS hardware tests. Hopefully that will guide me in pinpointing GBE+&#39;s faults on a low-level. Pretty sure the main hang-ups these days are related to reading from the game cart, and probably the timer interrupts. We&#39;ll see what happens. In the meantime, I&#39;ve made a list of things I want to tackle. No more being lazy. Time to really dive into this stuff. To that end, in addition to all of those 2D fixes, today I finished making GBE+ service NDS interrupts via HLE.</p>

				<p class="inner_text">This isn&#39;t as fancy as it sounds. Whenever an interrupt is fired, the CPU switches modes and jumps to a programmable address where that interrupt is handled by more game code. Once the interrupt is done, it jumps back to whatever code the game was doing before the interrupt fired (typically). The whole &#34;jump here to start, jump back to finish&#34; part belongs to code from the NDS BIOS. For simplicity, it&#39;s far easier to tell GBE+ to run that code rather than do the jump manually. However, interrupts are an essential part of most NDS games, so to run them properly, GBE+ needed the NDS BIOS files present as well. This was particularly annoying because GBE+ would complain if the BIOS weren&#39;t found, or it would freak out when trying to run NDS software without the BIOS. So I finally had enough and added the ability to manually handle NDS interrupt servicing.</p>

				<p class="inner_text">Like I said, it&#39;s nothing much. Just push or pop a couple of registers around the stack, calculate the jump address, and set the CPU modes appropiately. I&#39;d done the same thing in the GBA core, and it wasn&#39;t too different this time around. Interestingly enough, the NDS7 and NDS9 BIOS differ ever so slightly from the GBA BIOS when it comes time to service interrupts. NDS7 is most like the GBA, changing only 1 instruction, and even then, it&#39;s basically the same operation (mov r0, 0x4000000) just with a minor change in the opcode. The interrupt handling vector on NDS7 is at 0x380FFFC instead of the GBA&#39;s 0x3FFFFFC. Thanks to the way memory mirroring works on the NDS, however, 0x3FFFFFC holds the same value as 0x380FFFC.</p>

				<p class="inner_text">The NDS9 changes things up a bit more. The interrupt handling vector for that CPU is at the DTCM address + 0x3FFC. It floats around depending on wherever the DTCM is specified. To get this address, it has to ask the CP15 coprocessor. It does some quick masking (via bit shifting right, then left) and calculates the vector. But, aside from all that, pretty much the same as the GBA after that. At any rate, I can stop worrying about the BIOS settings in GBE+ when loading up tests!</p>

				<p class="inner_text">Next up on the list is more 3D software rendering. I feel like implementing a basic Z-buffer, then finally implementing color blending via vertices, and eventually texture support.</p>

				<p class="inner_text_large"><strong>August 23, 2018</strong></p>

				<p class="inner_text">Okay, honestly been too long since I updated here. Been too long since I touched anything NDS related. Almost close to finishing up better timings for the ARM7 and ARM9 CPUs. It&#39;s basically a done deal, just need to test it and make sure nothing explodes. Got real distracted with the Pocket Sonar on the Game Boy. Also got real distracted with Xenoblade Chronicles 2, investing ~90 hours beating that game in my spare time. Anyway, recently started playing Fire Emblem the Sacred Stones on GBE+ (yes, I use GBE+ for personal recreation and emulation) and I forgot how much effort I put into getting GBA games up and running. I&#39;ve mostly used GBE+ for DMG and GBC games, but GBA games are enjoyable in GBE+ too (in my biased opinion). Just kind of surprised me that I&#39;d actually want to play something from start to finish in a program I wrote myself. Anyway, it got me motivated to hit the NDS again. One of these days, I want to sit down, relax, and start playing DS games in GBE+ for fun.</p>

				<p class="inner_text">Today, nothing impressive, but I&#39;m reworking the way the software renderer fills in polygons. Previously I had some wacky code that tried to figure out a polygon&#39;s upper and lower boundaries based on vertices. It was pretty obtuse, what with sorting vertices and being only able to fill half-way before needing to switch around a bunch of coordinates. Just ugh, a mess. It segfaulted to boot when it encountered some extreme conditions too. Not my best work, for sure, although I didn&#39;t expect it to be. I&#39;ve never written a 3D software renderer, so I&#39;m just going on instincts when it comes to design.</p>

				<p class="inner_text">So I&#39;ve been meaning to improve the polygon fill method (for solid colors, haven&#39;t even attempted textures or even blended colors). GBE+ has pretty decent code to draw the polygon&#39;s outline, so I figured the simplest way to fill the polygon is to use coordinates directly from the outline. This gave me nice, clean coordinates that were always safely within bounds of the screen (the outline drawing code handles that stuff much better than my old poly-fill code). Reduced a couple hundred lines down to a few dozen! Probably performs better too, but I haven&#39;t done any metrics. So far, it&#39;s just the triangles that I&#39;ve reworked the filling code, but quads and strips aren&#39;t that big of a jump. We&#39;ll see if I can&#39;t tackle blended colors next.</p>

				<p class="inner_text_large"><strong>June 7, 2018</strong></p>

				<p class="inner_text">Not much to say besides I&#39;ve taken (yet another) serious attempt at fixing the timing of the ARM7 and ARM9 CPUs. I&#39;m fairly certain GBE+ is capable of running commerical games with everything that&#39;s been implemented to date. It&#39;s just that the timings were faked initially when development first started. Now there&#39;s no getting around it. I have to get them at least semi-accurate. There&#39;s a certain margin of error that&#39;s pretty generous (e.g. Desmume and no$gba aren&#39;t 100% accurate regarding timing, but that&#39;s not needed to get games running), however, GBE+ is wildly out of wack.</p>

				<p class="inner_text">To be honest, the timing code was copy+pasted from the GBA core since the ARM7 is virtually identical in the NDS, and in most regards the ARM9 is just a beefier, bigger brother to the ARM7 (it can actually be quite slower in practice thanks to how long it has to wait to access non-cached memory). Anyway, I only had a vague understanding of how the GBA was properly supposed to do timing, so as the NDS core evolved in GBE+ it became apparent that 2014 me had no idea how to do it right. Some ARM instructions in the GBA still don&#39;t have any timing at all. Thankfully most GBA games don&#39;t care, but I&#39;ll have to clean up that mess eventually too.</p>

				<p class="inner_text">While half-assing the GBA worked, it won&#39;t cut it on the NDS. So I took the time recently to really sit down and understand how the ARM7 and ARM9 operate when accessing memory and go back and examine just what&#39;s happening with a given instruction&#39;s timing. Had to dig through some source code from Desmume so I could grasp some concepts (like wtf the cache is doing on the ARM9), but I think I finally get all of the concepts that confused me like 4-5 years ago. Now comes the kinda boring part, trudging through all the CPU interpreter code that executes instructions and reworking timing with a new design. It&#39;s definitely not &#34;sexy&#34;, there&#39;s no whizz-bang graphics or sounds, but it&#39;s still work that has to be done. I&#39;m starting on the ARM7 side (since it&#39;s simpler) and writing homebrew tests for timing. I can see lots and lots of tests coming my way. At least I figured out how to draw text quite efficiently in assembly, which makes printing variables and other values relatively easy.</p>

				<p class="inner_text_large"><strong>May 15, 2018</strong></p>

				<p class="inner_text">I keep wanting to do another <a href="https://shonumi.github.io/articles/art3.html">big article</a> about NDS emulation, but I don&#39;t feel the time is right just yet. Maybe once I&#39;ve actually gotten commercial games up and running in GBE+, I&#39;ll finish writing the article I&#39;ve drafted about the NDS 2D engine. Plus, I&#39;m still busy with the <strong>Edge of Emulation</strong> articles. So I figured it&#39;d be nice to do something in-between. Nothing special, and much more laidback, and definitely something with a bit less fanfare. Something like a mini development blog based on whatever I happen to work on.</p>

				<p class="inner_text">So, I&#39;d ideally like to get NDS emulation stable in GBE+ by the end of this year. If I make one positive change to the codebase everyday, something that measurably improves the emulator, I&#39;ll get there, no problem. Much better than trying to push several giant changes all at once. Less pressure and more managable. That&#39;s really how I&#39;ve approached GBE+ since 2014, and my GitHub activity reflects that. One commit everyday. If you&#39;re always moving forward, eventually you gotta get there. Digressing, I need to get my head back in the game and get GBE+ running games. Time to focus (which is hopefully what these mini-blogs will help with.)</p>

				<p class="inner_text">Today, focusing on 3D stuff. GBE+ has basic support for 3D rendering via software. It mostly just draws the lines of triangles and quads (no strips yet), and that&#39;s it, just colored outlines. It&#39;s not much, but it&#39;s something to start with. One annoying problem was that some libnds demos would instantly start &#34;shrinking&#34; all polygons by sending them away from the camera along the z-axis. Couldn&#39;t figure out what was going wrong just by looking at it, so I tried disabling a bunch of GX commands sent to the NDS 3D engine. None of them was the culprit, so on a hunch I guessed one of the matrices used to calculate positions was incorrect. Sure enough, the dedicated position matrix (and thereby the clip matrix) was wonky. They kept increasing certain values whenever it was multiplied. Now, you&#39;d expect values to change when something is multiplied (by something other than 1), but an identity matrix was supposed to be loaded right before the matrix multiplication. The values should have been consistent, not infinitely expanding.</p>

				<p class="inner_text">The lesson I learned is never assume your code does what you think it does unless you check it up and down. My matrix had specific code convert it into an identity matrix, or so I thought. I mistakenly believed it was clearing the entire matrix before adding the diagonal line of 1s. It added the 1s just fine, but it didn&#39;t erase the other elements. So every time matrix multiplication was called, my &#34;identity&#34; matrix still had values from the last multiplication! Literally took one line of code to fix (calling the <strong>clear()</strong> function I made for that very purpose) but mystery solved.</p>

				<p class="center_img">
					<img class="space_img" src="ndsr_1.png" alt="Triangles are better than squares. Mass Blaster proves it.">
				</p>

				<p class="img_caption">Before, this would zoom off into the background like a rocket doing spirals. Not much, but progress is progress</p>

			</div>
		</div>

	</body>
</html>

		

		